Шах игра

**1. Објаснување на проблемот**

Целта на нашата проектна задача е имплементација на компјутерска игра шах, која овозможува двајца играчи да играат еден против друг. Основните функционалности вклучуваат:
Интерфејс за играње шах.
 - Можност за движење на фигури според правилата на шах.
 - Визуелна репрезентација на таблата и фигурите.
 - Валидација на потези (дозволени и недозволени потези).
 - Систем за следење на состојбата на играта.
Апликацијата служи за забава и развој на стратешки вештини преку играње на класичната игра шах. Играта е наменета за двајца играчи, кои можат да играат на еден компјутер.
Шах е друштвена игра за двајца играчи, која се игра на табла со 64 полиња распоредени во 8x8 мрежа. Секој играч има по 16 фигури: 1 крал, 1 кралица, 2 топа, 2 коњи, 2 ловци и 8 пешаци. Целта на играта е да се постави противниковиот крал во состојба на мат (шах-мат), каде што кралот е нападнат и не може да избега.

![image](https://github.com/anabaleska/chess/assets/174952938/af8480ea-62ad-4c1c-9e62-3774f690968a)


**2. Опис на решението**

Решението на проблемот е имплементирано преку објектно-ориентиран дизајн во C#. Проектот е поделен на два главни дела: логика на шаховската игра (ChessLogic) и корисничкиот интерфејс (ChessUI).

**Логика на играта (ChessLogic):**

**Piece.cs:** Базична класа која ги дефинира основните карактеристики и методи за сите шаховски фигури. Содржи информации типот на фигурата, на кој играч припаѓа и која боја е.
**Pawn.cs**, **Bishop.cs**, **Knight.cs**, **Rook.cs**, **Queen.cs**, **King.cs**: Наследуваат од Piece.cs и ги дефинираат специфичните движења и правила за секоја шаховска фигура.
**Move.cs**: Базична класа која ги дефинира основните карактеристики и правила за потези на фигури. Оваа класа содржи информации како почетна и крајна позиција на фигурата, типот на потегот, како и дали потегот е валиден.
**NormalMove.cs**: Класа која наследува од класата Move.cs, дефинира основно/нормално придвижување на фигура од позиција „од“ до позиција „до“
**Castle.cs**: Класа која наследува од класата Move.cs, дефинира специјален тип на потег- рокада, каде кралот и топот се движат истовремено, дали е кратка или долга рокада и дали истата е возможна.
**DoublePawn.cs**: Класа која наследува од класата Move.cs, ја моделира специјалната појава кога пешакот се движи две полиња напред од почетната позиција.
**EnPassant.cs**: Класа која наследува од класата Move.cs, ја моделира специјалната појава каде пешакот го зема противничкиот пешак кој е поместен две полиња напред (направил движење под типот DoublePawn).
**PawnPromotion.cs**: Класа која наследува од класата Move.cs, го дефинира случајот на промоција на пешакот кога ќе го стигне спротивниот крај од таблата во друга земена фигура (може да е кралица, топ, ловец или коњ).
**Board.cs**: Го дефинира распоредот на таблата и ги чува сите фигури на неа. Содржи методи за иницијализација на таблата, валидација на потези и ажурирање на состојбата на таблата по секој потег без разлика на типот.
**GameState.cs**: Го следи текот на играта, вклучувајќи информации за тековниот играч, состојбата на играта и бројот на потези.
**Player.cs**: Ги дефинира карактеристиките на играчите, вклучувајќи информации за типот на играчот (бел или црн), како и метод за наоѓање на противникот на играчот кој е проследен.
**Position.cs**: Ја дефинира позицијата на таблата користејќи координати (ред и колона).
**Direction.cs**, MoveType.cs, PieceType.cs, EndReason.cs: Дополнителни енумерации и помошни класи кои ја поедноставуваат логиката за управување со потези и состојби на играта.
**StateString.cs**:  ја моделира моменталната состојба на шаховската табла во формат на стринг. Оваа класа користи StringBuilder за ефикасно создавање на стрингот кој ја претставува состојбата (потребно за ефикасно завршување на играта).
**Counting.cs**: Класата се користи за броење на шаховските фигури по тип и боја, важно за одредување на завршница на играта во зависност од бројот на фигури останати на таблата.
**Result.cs**: Класа која ја моделира завршната состојба на шаховска партија, овозможувајќи лесно ракување со информации за победникот и причината за завршување.

**Кориснички интерфејс (ChessUI):**

MainWindow.xaml, GameOverMenu.xaml, PauseMenu.xaml и PromotionMenu.xaml: Дефинираат изгледот на главниот прозорец на апликацијата, менито кое се појавува по завршување на играта, менито кое се појавува во случај на паузирање на играта при притиснување на ‘esc’ копчето и мени за избор на промоција на пешакот во друга фигура.
MainWindow.xaml.cs: Содржи логиката за визуелизација на таблата и интеракцијата со корисникот, вклучувајќи ја обработката на кликови на таблата и ажурирање на визуелниот приказ.
GameOverMenu.xaml.cs: Управува со приказот на менито по завршување на играта, нудејќи опции како нова игра или излез.
PauseMenu.xaml.cs: Претставува корисничка контрола за менито за пауза во шаховска апликација. Оваа класа наследува од UserControl и ја дефинира функционалноста на менито за пауза, дали да се продолжи или да се рестартира играта.
PromotionMenu.xaml.cs: Претставува корисничка контрола за менито за промоција на пешак во шаховска апликација. Оваа класа наследува од UserControl.
Images.cs: Управува со сликите и визуелните елементи на фигурите зачувани во Assets, овозможувајќи прикажување на различни фигури на таблата.
Assets и ChessCursors.cs: Содржат помошни датотеки и курсори за подобро корисничко искуство.
Option.cs: Енумерација која ги содржи опции кои би можеле да се изберат од менијата.

**3. Опис на класта GameState.cs**

Класата GameState е одговорна за управување со состојбата на играта шах, следење на тековниот играч, таблата и резултатот на играта. Таа обезбедува методи за генерирање на легални потези, извршување на потези и проверка на крајната состојба на играта.
namespace ChessLogic
{
    public class GameState
    {
        public Board Board { get;  }
        public Player CurrentPlayer { get; private set; }
        public Result Result { get; private set; } = null;

        private int noCaptureOrPawnMoves = 0;
        private string stateString;
        private readonly Dictionary<string, int> stateHistory = new Dictionary<string, int>();

        public GameState(Player player, Board board)
        {
            CurrentPlayer = player;
            Board = board;

            stateString = new StateString(CurrentPlayer, board).ToString();
            stateHistory[stateString] = 1;
        }

        public IEnumerable<Move> LegalMovesForPieces(Position pos)
        {
            if(Board.IsEmpty(pos) || Board[pos].Color != CurrentPlayer)
            {
                return Enumerable.Empty<Move>();
            }

            Piece piece = Board[pos];
            IEnumerable<Move> moveCandidates = piece.GetMoves(pos, Board);
            return moveCandidates.Where(move => move.IsLegal(Board));
        }

        public void MakeMove(Move move)
        {
            Board.SetPawnSkipPosition(CurrentPlayer, null);
            bool captureOrPawn = move.Execute(Board);
            if (captureOrPawn)
            {
                noCaptureOrPawnMoves = 0;
                stateHistory.Clear();
            }
            else
            {
                noCaptureOrPawnMoves++;
            }
            CurrentPlayer = CurrentPlayer.Opponent();
            UpdateStateString();
            CheckForGameOver();
        }

        public IEnumerable<Move> AllLegalMoovesFor(Player player)
        {
            IEnumerable<Move> moveCandidates = Board.PiecePositionsFor(player).SelectMany(pos =>
            {
                Piece piece = Board[pos];
                return piece.GetMoves(pos, Board);
            });
            return moveCandidates.Where(move => move.IsLegal(Board));
        }

        private void CheckForGameOver()
        {
            if (!AllLegalMoovesFor(CurrentPlayer).Any())
            {
                if (Board.IsInCheck(CurrentPlayer))
                {
                    Result = Result.Win(CurrentPlayer.Opponent());
                     
                }
                else
                {
                    Result = Result.Draw(EndReason.Statemate);
                }
            }
            else if (Board.InsufficientMaterial())
            {
                Result = Result.Draw(EndReason.InsufficientMaterial);
            }
            else if (FiftyMoveRule())
            {
                Result = Result.Draw(EndReason.FiftyMoveRule);
            }

            else if (ThreefoldRepetition())
            {
                Result = Result.Draw(EndReason.ThreefoldRepetition);
            }
        }
        public bool IsGameOver()
        {
            return Result != null;
        }

        private bool FiftyMoveRule()
        {
            int fullMoves = noCaptureOrPawnMoves / 2;
            return fullMoves == 50;
        }

        private void UpdateStateString()
        {
            stateString = new StateString(CurrentPlayer, Board).ToString();

            if (!stateHistory.ContainsKey(stateString))
            {
                stateHistory[stateString] = 1;
            }
            else
            {
                stateHistory[stateString]++;
            }
        }

        private bool ThreefoldRepetition()
        {
            return stateHistory[stateString] == 3;
        }
    }
}

**Објаснување на кодот:**

**Полиња и конструктор:**
public Board Board { get; }: Чува инстанца од класата Board, која ја претставува тековната состојба на шаховската табла.
public Player CurrentPlayer { get; private set; }: Чува информација за тековниот играч кој е на потег.
public Result Result { get; private set; } = null;  Чува резултат на играта. Иницијално е поставен на null.
private int noCaptureOrPawnMoves = 0; Бројач за направени потези без фаќање или поместување на пешакот.
private string stateString; Стринг кој ја претставува моменталната состојба на таблата.
private readonly Dictionary<string, int> stateHistory = new Dictionary<string, int>(); Речник кој ја чува историјата на состојбите на таблата и нивната фреквенција.
Конструкторот GameState(Player player, Board board) ја иницијализира состојбата на играта со дадените играч, табла и го поставува почетниот stateString и го додава во stateHistory.

**Метод за легални потези на фигури:**
public IEnumerable<Move> LegalMovesForPieces(Position pos): Го враќа сетот на легални потези за фигурата на дадената позиција.
Ако позицијата е празна или фигурата не е на тековниот играч, враќа празен сет потези.
Инаку, ги зема сите потези за фигурата на таа позиција и ги филтрира само легалните потези.

**Метод за извршување потег:**
public void MakeMove(Move move): Го извршува дадениот потег, ја ажурира таблата и го менува тековниот играч.
По извршувањето на потегот, се повикува CheckForGameOver() за да провери дали играта завршила.

**Метод за сите легални потези на играчот:**
public IEnumerable<Move> AllLegalMoovesFor(Player player): Ги враќа сите легални потези за дадениот играч.
Ги собира сите можни потези за сите фигури на играчот и ги филтрира само легалните потези.

**Метод за проверка на крај на играта:**
private void CheckForGameOver(): Проверува дали играта е завршена.
Ако нема легални потези за тековниот играч и ако е во шах, играчот губи, а противникот победува.
Ако нема легални потези, но играчот не е во шах, играта завршува со реми.
Ако нема доволно фигури на таблата завршува со недостаток на материјал.
Ако се направени 50 потези без земање на фигура или поместување на пешак завршува со педесет потези преку повикување на методот private bool ThreefoldRepetition().
Ако истата позиција на таблата се има повторено три пати во stateHistory, со истот играч на ред и истите фигури со истите права на движење, вклучувајќи го и правото за рокада или земање на пион ен-пасант преку повикување на методот private bool FiftyMoveRule().

**Метод за ажурирање на стрингот на состојба:**
private void UpdateStateString(): проверува дали stateHistory речникот веќе го содржи stateString како клуч, се додава запис во случај да нема, или се инкрементира клучот ако има.

**Метод за проверка дали играта е завршена:**
public bool IsGameOver(): Проверува дали играта е завршена врз основа на резултатот.


**4. Упатство за играта:**
   
Секој играч има по 16 фигури: еден крал, една кралица, два топа, два ловца, два коњи и осум пешаци. Целта на играта е да се даде шах-мат на противничкиот крал, што значи да се загрози на начин што не може да се избегне нападот. Играчите наизменично прават потези, поместувајќи ги своите фигури според специфични правила за движење за секоја фигура. Играта може да заврши и со реми поради различни причини, како недостаток на материјал за шах-мат, педесет потези правило, тројно повторување на истата позиција или договор меѓу играчите. 
Правење потези: Кликнете на фигурата што сакате да ја поместите, проектирани ви се досволени позиции и поместете ја фигурата на целната позиција на таблата.
Менито за промоција: Кога пешак стигнува до спротивната страна на таблата, одберете ја фигурата за промоција од менито.
Пауза и рестарт: Кликнете на „esc“ за да ја паузирате играта, а потоа одберете "Continue" за продолжување или "Restart" за нова партија.
Завршување на играта: Играта завршува кога еден од играчите ќе добие шах-мат, или ќе се постигне реми поради недостаток на легални потези, педесет потези правило или тројно повторување.



